#!/usr/bin/env bash
set -euo pipefail

readonly COLOR_RESET="\033[0m"
readonly BRIGHT_RED="\033[1;31m"
readonly BRIGHT_GREEN="\033[1;32m"
readonly BRIGHT_YELLOW="\033[1;33m"
readonly BRIGHT_BLUE="\033[1;34m"
# readonly IFS=' '
SCRIPT_PATH=$(realpath "$0")
SCRIPT_DIR=$(dirname "$SCRIPT_PATH")

SUCCESS=0
SUCCESS_SKIP=1
SUCCESS_WARN=2
FAIL=3

cmd_code=$SUCCESS
cmd_msg=""
cmd_location=""

source "${SCRIPT_DIR}/.env"
source "${SCRIPT_DIR}/apt"
source "${SCRIPT_DIR}/arch"

pushd() {
    command pushd "$@" >/dev/null
}

popd() {
    command popd >/dev/null
}
__log() {
    name="$1"
    state="$2"
    color="$3"
    msg="$4"
    echo -e "${color}[ dm:${name} ] ${state} |${COLOR_RESET} ${msg}"
}

__info() {
    if [ $# -gt 0 ]; then
        name="$1"
        msg="$2"
    else
        name="$cmd_location"
        msg="$cmd_msg"
    fi
    __log "$name" "INFO" "$BRIGHT_BLUE" "$msg"
}

__warn() {
    # if [ $# -gt 0 ]; then
    #     name="$1"
    #     msg="$2"
    # else
    #     name="$cmd_location"
    #     msg="$cmd_msg"
    # fi
    name="$cmd_location"
    msg="$cmd_msg"
    __log "$name" "WARN" "$BRIGHT_YELLOW" "$msg"
}

__fail() {
    # if [ $# -gt 0 ]; then
    #     name="$1"
    #     msg="$2"
    # else
    #     name="$cmd_location"
    #     msg="$cmd_msg"
    # fi
    name="$cmd_location"
    msg="$cmd_msg"
    __log "$name" "FAIL" "$BRIGHT_RED" "$msg"
}

__success() {
    if [ $# -gt 0 ]; then
        name="$1"
        msg="$2"
    else
        name="$cmd_location"
        msg="$cmd_msg"
    fi
    __log "$name" "SUCCESS" "$BRIGHT_GREEN" "$msg"
}

__handle_err() {
    case "$cmd_code" in
    "$SUCCESS_SKIP") __success ;;
    "$SUCCESS_WARN") __warn ;;
    "$FAIL")
        __fail
        exit "$cmd_code"
        ;;
    esac

    cmd_code=$SUCCESS
    cmd_msg=""
    cmd_location=""
}

dm_repos() {
    name="repos"
    __info "$name" "starting"

    for r in "${REPOS[@]}"; do
        repo_name=$(echo "$r" | sed -E "s/.*tbreslein\/(.*).git$/\1/g")
        repo_dir="$HOME/code/${repo_name}"
        if [ -d "$repo_dir" ]; then
            pushd "$repo_dir"
            git pull &
            popd
        else
            git clone "$r" "$repo_dir" &
        fi
    done
    wait

    __success "$name" "finished"
}

dm_stow() {
    name="stow"
    __info "$name" "starting"
    if [ "$(git status --porcelain)" != "" ]; then
        cmd_code=$FAIL
        cmd_location="stow"
        cmd_msg="cannot run stow in dirty repos"
        return
    fi

    stows=("all" "colours/${COLOURS}" "$_HOST")
    for r in "${ROLES[@]}"; do
        if [[ "$r" =~ ^rbpi|wsl$ ]]; then
            continue
        fi
        stows+=("$r")
        if [[ "$r" == "desktop" && "$UNAME_S" == "linux" ]]; then
            stows+=("linux-desktop")
        fi
    done

    for s in "${stows[@]}"; do
        stow_dir="${HOME}/dots/stows/${s}"
        if [ ! -d "$stow_dir" ]; then
            cmd_code=$FAIL
            cmd_location="stow"
            cmd_msg="stow dir does not exist: ${stow_dir}"
            return
        fi
        stow --restow --no-folding --adopt -t "$HOME" -d "$stow_dir" .
    done
    git restore .

    if [ ! -d "${HOME}/.config/nvim" ]; then
        ln -s "${HOME}/dots/nvim" "${HOME}/.config/"
    fi

    __success "$name" "finished"
}

dm_nix() {
    name="nix"
    __info "$name" "starting"
    nix-channel --update
    nix-store --gc --optimise
    __success "$name" "finished"
}

dm_pkgs() {
    name="pkgs"
    __info "$name" "starting"
    case "$_HOST" in
    "darwin")
        prep_pkgs "brew"
        brew bundle --cleanup --file "${SCRIPT_DIR}/Brewfile" install
        ;;

    "vorador")
        prep_pkgs "apt"
        apt_install=$(tr '\n' ' ' <"$HOME/dots/state/apt_install")
        apt_remove=$(tr '\n' ' ' <"$HOME/dots/state/apt_remove")
        sudo apt remove "$apt_remove"
        sudo apt update
        sudo apt upgrade
        sudo apt install "$apt_install"
        sudo apt autoremove
        mv "$HOME/dots/state/apt_want" "$HOME/dots/state/apt_current"
        rm "$HOME"/dots/state/apt_{install,remove}
        ;;

    "moebius" | "audron" | "moebius-win")
        prep_pkgs "pacman"
        pacman_install=$(tr '\n' ' ' <"$HOME/dots/state/pacman_install")
        pacman_remove=$(tr '\n' ' ' <"$HOME/dots/state/pacman_remove")
        prep_pkgs "aur"
        aur_install=$(tr '\n' ' ' <"$HOME/dots/state/aur_install")
        aur_remove=$(tr '\n' ' ' <"$HOME/dots/state/aur_remove")

        sudo pacman -R "$pacman_remove"
        sudo pacman -Syu
        sudo pacman -S "$pacman_install"

        paru -R "$aur_remove"
        paru
        paru -S "$aur_install"

        mv "$HOME/dots/state/pacman_want" "$HOME/dots/state/pacman_current"
        rm "$HOME"/dots/state/pacman_{install,remove}
        mv "$HOME/dots/state/aur_want" "$HOME/dots/state/aur_current"
        rm "$HOME"/dots/state/aur_{install,remove}
        ;;
    esac
    if command -v rustup &> /dev/null; then
        rustup update
    fi
    __success "$name" "finished"
}

prep_pkgs() {
    pkg_manager="$1"
    state_dir="$HOME/dots/state"
    current_state="${state_dir}/${1}_current"
    want="${state_dir}/${1}_want"
    install="${state_dir}/${1}_install"
    remove="${state_dir}/${1}_remove"

    truncate -s0 "$want"
    truncate -s0 "$install"
    truncate -s0 "$remove"

    touch "$current_state"
    touch "$want"
    touch "$install"
    touch "$remove"

    if [[ "$pkg_manager" == "apt" ]]; then
        pkgs=("${APT[@]}")
    elif [[ "$pkg_manager" == "pacman" ]]; then
        pkgs=("${PACMAN[@]}")
    elif [[ "$pkg_manager" == "aur" ]]; then
        pkgs=("${AUR[@]}")
    fi

    IFS=$'\n' pkgs=("$(sort -n <<<"${pkgs[*]}")")

    for p in "${pkgs[@]}"; do
        echo "$p" >>"$want"
    done

    comm -23 "$want" "$current_state" >"$install"
    comm -13 "$want" "$current_state" >"$remove"
}

dm_nvim() {
    name="nvim"
    __info "$name" "starting"
    nvim --headless -c "MasonUpdate" -c "MasonUpdateAll" -c "Lazy! sync" -c "TSUpdateSync" -c "qa"
    __success "$name" "finished"
}

dm_sync() {
    __info "sync" "starting"

    dm_repos
    __handle_err

    dm_stow
    __handle_err

    dm_nix
    __handle_err

    dm_pkgs
    __handle_err

    dm_nvim
    __handle_err

    __success "sync" "finished"
}

__main() {
    mkdir -p ~/.config ~/.local/bin ~/dots/state
    for c in "${COMMANDS[@]}"; do
        case "$c" in
        "repos") dm_repos ;;
        "stow") dm_stow ;;
        "nix") dm_nix ;;
        "pkgs") dm_pkgs ;;
        "nvim") dm_nvim ;;
        "sync") dm_sync ;;
        esac
        __handle_err
    done
    __handle_err
}

COMMANDS=()
if [ $# -gt 0 ]; then
    read -ra COMMANDS <<<"$@"
else
    COMMANDS=("sync")
fi

IFS=' ' read -ra ROLES <<<"$ROLES"
IFS=' ' read -ra REPOS <<<"$REPOS"
__main
