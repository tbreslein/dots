#!/usr/bin/env bash
set -euo pipefail

readonly COLOR_RESET="\033[0m"
readonly BRIGHT_RED="\033[1;31m"
readonly BRIGHT_GREEN="\033[1;32m"
readonly BRIGHT_YELLOW="\033[1;33m"
readonly BRIGHT_BLUE="\033[1;34m"
readonly IFS=' '
SCRIPT_PATH=$(realpath "$0")
SCRIPT_DIR=$(dirname "${SCRIPT_PATH}")

SUCCESS=0
SUCCESS_SKIP=1
SUCCESS_WARN=2
FAIL=3

cmd_code=$SUCCESS
cmd_msg=""
cmd_location=""

source "${SCRIPT_DIR}/.env"

pushd() {
    command pushd "$@" >/dev/null
}

popd() {
    command popd "$@" >/dev/null
}
__log() {
    name="$1"
    state="$2"
    color="$3"
    msg="$4"
    echo -e "${color}[ dm:${name} ] ${state} |${COLOR_RESET} ${msg}"
}

__info() {
    if [ $# -gt 0 ]; then
        name="$1"
        msg="$2"
    else
        name="$cmd_location"
        msg="$cmd_msg"
    fi
    __log "$name" "INFO" "$BRIGHT_BLUE" "$msg"
}

__warn() {
    if [ $# -gt 0 ]; then
        name="$1"
        msg="$2"
    else
        name="$cmd_location"
        msg="$cmd_msg"
    fi
    __log "$name" "WARN" "$BRIGHT_YELLOW" "$msg"
}

__fail() {
    if [ $# -gt 0 ]; then
        name="$1"
        msg="$2"
    else
        name="$cmd_location"
        msg="$cmd_msg"
    fi
    __log "$name" "FAIL" "$BRIGHT_RED" "$msg"
}

__success() {
    if [ $# -gt 0 ]; then
        name="$1"
        msg="$2"
    else
        name="$cmd_location"
        msg="$cmd_msg"
    fi
    __log "$name" "SUCCESS" "$BRIGHT_GREEN" "$msg"
}

__handle_err() {
    case "$cmd_code" in
    "$SUCCESS_SKIP") __success ;;
    "$SUCCESS_WARN") __warn ;;
    "$FAIL")
        __fail
        exit $cmd_code
        ;;
    esac

    cmd_code=$SUCCESS
    cmd_msg=""
    cmd_location=""
}

dm_repos() {
    name="repos"
    __info "$name" "starting"

    for r in "${REPOS[@]}"; do
        repo_name=$(echo "$r" | sed -E "s/.*tbreslein\/(.*).git$/\1/g")
        repo_dir="$HOME/code/${repo_name}"
        if [ -d "${repo_dir}" ]; then
            pushd "$repo_dir"
            git pull &
            popd
        else
            git clone "$r" "$repo_dir" &
        fi
    done
    wait

    __success "$name" "finished"
}

dm_stow() {
    name="stow"
    __info "$name" "starting"
    if [ -n "$(git status --porcelain)" ]; then
        cmd_code=$FAIL
        cmd_location="stow"
        cmd_msg="cannot run stow in dirty repos"
        return
    fi

    stows=("all" "colours/${COLOURS}" "${_HOST}")
    for r in "${ROLES[@]}"; do
        stows+=("$r")
        if [[ "$r" == "desktop" && "${UNAME_S}" == "linux" ]]; then
            stows+=("linux-desktop")
        fi
    done

    for s in "${stows[@]}"; do
        stow_dir="${HOME}/dots/stows/${s}"
        if [ ! -d "${stow_dir}" ]; then
            cmd_code=$FAIL
            cmd_location="stow"
            cmd_msg="stow dir does not exist: ${stow_dir}"
            return
        fi
        stow --no-folding --adopt -t "${HOME}" -d "${stow_dir}" .
    done
    git restore .

    if [ ! -d "${HOME}/.config/nvim" ]; then
        ln -s "${HOME}/dots/nvim" "${HOME}/.config/"
    fi

    __success "$name" "finished"
}

dm_nix() {
    name="nix"
    __info "$name" "starting"
    __success "$name" "finished"
}

dm_pkgs() {
    name="pkgs"
    __info "$name" "starting"
    __success "$name" "finished"
}

dm_nvim() {
    name="nvim"
    __info "$name" "starting"
    __success "$name" "finished"
}

dm_sync() {
    __info "sync" "starting"

    dm_repos
    __handle_err

    dm_stow
    __handle_err

    dm_nix
    __handle_err

    dm_pkgs
    __handle_err

    dm_nvim
    __handle_err

    __success "sync" "finished"
}

__main() {
    mkdir -p ~/.config ~/.local/bin ~/dots/state
    for c in "${COMMANDS[@]}"; do
        case "$c" in
        "repos") dm_repos ;;
        "stow") dm_stow ;;
        "nix") dm_nix ;;
        "pkgs") dm_pkgs ;;
        "nvim") dm_nvim ;;
        "sync") dm_sync ;;
        esac
        __handle_err
    done
    __handle_err
}

COMMANDS=()
if [ $# -gt 0 ]; then
    read -ra COMMANDS <<<"$@"
else
    COMMANDS=("sync")
fi

read -ra ROLES <<<"$ROLES"
read -ra REPOS <<<"$REPOS"

__main
